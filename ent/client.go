// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"wishlist-wrangler-api/ent/migrate"

	"wishlist-wrangler-api/ent/loginrequest"
	"wishlist-wrangler-api/ent/user"
	"wishlist-wrangler-api/ent/wishlist"
	"wishlist-wrangler-api/ent/wishlistsection"
	"wishlist-wrangler-api/ent/wishlisttemplate"
	"wishlist-wrangler-api/ent/wishlisttemplatesection"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// LoginRequest is the client for interacting with the LoginRequest builders.
	LoginRequest *LoginRequestClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Wishlist is the client for interacting with the Wishlist builders.
	Wishlist *WishlistClient
	// WishlistSection is the client for interacting with the WishlistSection builders.
	WishlistSection *WishlistSectionClient
	// WishlistTemplate is the client for interacting with the WishlistTemplate builders.
	WishlistTemplate *WishlistTemplateClient
	// WishlistTemplateSection is the client for interacting with the WishlistTemplateSection builders.
	WishlistTemplateSection *WishlistTemplateSectionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.LoginRequest = NewLoginRequestClient(c.config)
	c.User = NewUserClient(c.config)
	c.Wishlist = NewWishlistClient(c.config)
	c.WishlistSection = NewWishlistSectionClient(c.config)
	c.WishlistTemplate = NewWishlistTemplateClient(c.config)
	c.WishlistTemplateSection = NewWishlistTemplateSectionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		LoginRequest:            NewLoginRequestClient(cfg),
		User:                    NewUserClient(cfg),
		Wishlist:                NewWishlistClient(cfg),
		WishlistSection:         NewWishlistSectionClient(cfg),
		WishlistTemplate:        NewWishlistTemplateClient(cfg),
		WishlistTemplateSection: NewWishlistTemplateSectionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		LoginRequest:            NewLoginRequestClient(cfg),
		User:                    NewUserClient(cfg),
		Wishlist:                NewWishlistClient(cfg),
		WishlistSection:         NewWishlistSectionClient(cfg),
		WishlistTemplate:        NewWishlistTemplateClient(cfg),
		WishlistTemplateSection: NewWishlistTemplateSectionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		LoginRequest.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.LoginRequest, c.User, c.Wishlist, c.WishlistSection, c.WishlistTemplate,
		c.WishlistTemplateSection,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.LoginRequest, c.User, c.Wishlist, c.WishlistSection, c.WishlistTemplate,
		c.WishlistTemplateSection,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *LoginRequestMutation:
		return c.LoginRequest.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *WishlistMutation:
		return c.Wishlist.mutate(ctx, m)
	case *WishlistSectionMutation:
		return c.WishlistSection.mutate(ctx, m)
	case *WishlistTemplateMutation:
		return c.WishlistTemplate.mutate(ctx, m)
	case *WishlistTemplateSectionMutation:
		return c.WishlistTemplateSection.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// LoginRequestClient is a client for the LoginRequest schema.
type LoginRequestClient struct {
	config
}

// NewLoginRequestClient returns a client for the LoginRequest from the given config.
func NewLoginRequestClient(c config) *LoginRequestClient {
	return &LoginRequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginrequest.Hooks(f(g(h())))`.
func (c *LoginRequestClient) Use(hooks ...Hook) {
	c.hooks.LoginRequest = append(c.hooks.LoginRequest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginrequest.Intercept(f(g(h())))`.
func (c *LoginRequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginRequest = append(c.inters.LoginRequest, interceptors...)
}

// Create returns a builder for creating a LoginRequest entity.
func (c *LoginRequestClient) Create() *LoginRequestCreate {
	mutation := newLoginRequestMutation(c.config, OpCreate)
	return &LoginRequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginRequest entities.
func (c *LoginRequestClient) CreateBulk(builders ...*LoginRequestCreate) *LoginRequestCreateBulk {
	return &LoginRequestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginRequestClient) MapCreateBulk(slice any, setFunc func(*LoginRequestCreate, int)) *LoginRequestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginRequestCreateBulk{err: fmt.Errorf("calling to LoginRequestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginRequestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginRequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginRequest.
func (c *LoginRequestClient) Update() *LoginRequestUpdate {
	mutation := newLoginRequestMutation(c.config, OpUpdate)
	return &LoginRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginRequestClient) UpdateOne(lr *LoginRequest) *LoginRequestUpdateOne {
	mutation := newLoginRequestMutation(c.config, OpUpdateOne, withLoginRequest(lr))
	return &LoginRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginRequestClient) UpdateOneID(id uuid.UUID) *LoginRequestUpdateOne {
	mutation := newLoginRequestMutation(c.config, OpUpdateOne, withLoginRequestID(id))
	return &LoginRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginRequest.
func (c *LoginRequestClient) Delete() *LoginRequestDelete {
	mutation := newLoginRequestMutation(c.config, OpDelete)
	return &LoginRequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginRequestClient) DeleteOne(lr *LoginRequest) *LoginRequestDeleteOne {
	return c.DeleteOneID(lr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginRequestClient) DeleteOneID(id uuid.UUID) *LoginRequestDeleteOne {
	builder := c.Delete().Where(loginrequest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginRequestDeleteOne{builder}
}

// Query returns a query builder for LoginRequest.
func (c *LoginRequestClient) Query() *LoginRequestQuery {
	return &LoginRequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginRequest entity by its id.
func (c *LoginRequestClient) Get(ctx context.Context, id uuid.UUID) (*LoginRequest, error) {
	return c.Query().Where(loginrequest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginRequestClient) GetX(ctx context.Context, id uuid.UUID) *LoginRequest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoginRequestClient) Hooks() []Hook {
	return c.hooks.LoginRequest
}

// Interceptors returns the client interceptors.
func (c *LoginRequestClient) Interceptors() []Interceptor {
	return c.inters.LoginRequest
}

func (c *LoginRequestClient) mutate(ctx context.Context, m *LoginRequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginRequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginRequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LoginRequest mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// WishlistClient is a client for the Wishlist schema.
type WishlistClient struct {
	config
}

// NewWishlistClient returns a client for the Wishlist from the given config.
func NewWishlistClient(c config) *WishlistClient {
	return &WishlistClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wishlist.Hooks(f(g(h())))`.
func (c *WishlistClient) Use(hooks ...Hook) {
	c.hooks.Wishlist = append(c.hooks.Wishlist, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wishlist.Intercept(f(g(h())))`.
func (c *WishlistClient) Intercept(interceptors ...Interceptor) {
	c.inters.Wishlist = append(c.inters.Wishlist, interceptors...)
}

// Create returns a builder for creating a Wishlist entity.
func (c *WishlistClient) Create() *WishlistCreate {
	mutation := newWishlistMutation(c.config, OpCreate)
	return &WishlistCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Wishlist entities.
func (c *WishlistClient) CreateBulk(builders ...*WishlistCreate) *WishlistCreateBulk {
	return &WishlistCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WishlistClient) MapCreateBulk(slice any, setFunc func(*WishlistCreate, int)) *WishlistCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WishlistCreateBulk{err: fmt.Errorf("calling to WishlistClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WishlistCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WishlistCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Wishlist.
func (c *WishlistClient) Update() *WishlistUpdate {
	mutation := newWishlistMutation(c.config, OpUpdate)
	return &WishlistUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WishlistClient) UpdateOne(w *Wishlist) *WishlistUpdateOne {
	mutation := newWishlistMutation(c.config, OpUpdateOne, withWishlist(w))
	return &WishlistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WishlistClient) UpdateOneID(id uuid.UUID) *WishlistUpdateOne {
	mutation := newWishlistMutation(c.config, OpUpdateOne, withWishlistID(id))
	return &WishlistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Wishlist.
func (c *WishlistClient) Delete() *WishlistDelete {
	mutation := newWishlistMutation(c.config, OpDelete)
	return &WishlistDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WishlistClient) DeleteOne(w *Wishlist) *WishlistDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WishlistClient) DeleteOneID(id uuid.UUID) *WishlistDeleteOne {
	builder := c.Delete().Where(wishlist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WishlistDeleteOne{builder}
}

// Query returns a query builder for Wishlist.
func (c *WishlistClient) Query() *WishlistQuery {
	return &WishlistQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWishlist},
		inters: c.Interceptors(),
	}
}

// Get returns a Wishlist entity by its id.
func (c *WishlistClient) Get(ctx context.Context, id uuid.UUID) (*Wishlist, error) {
	return c.Query().Where(wishlist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WishlistClient) GetX(ctx context.Context, id uuid.UUID) *Wishlist {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WishlistClient) Hooks() []Hook {
	return c.hooks.Wishlist
}

// Interceptors returns the client interceptors.
func (c *WishlistClient) Interceptors() []Interceptor {
	return c.inters.Wishlist
}

func (c *WishlistClient) mutate(ctx context.Context, m *WishlistMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WishlistCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WishlistUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WishlistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WishlistDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Wishlist mutation op: %q", m.Op())
	}
}

// WishlistSectionClient is a client for the WishlistSection schema.
type WishlistSectionClient struct {
	config
}

// NewWishlistSectionClient returns a client for the WishlistSection from the given config.
func NewWishlistSectionClient(c config) *WishlistSectionClient {
	return &WishlistSectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wishlistsection.Hooks(f(g(h())))`.
func (c *WishlistSectionClient) Use(hooks ...Hook) {
	c.hooks.WishlistSection = append(c.hooks.WishlistSection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wishlistsection.Intercept(f(g(h())))`.
func (c *WishlistSectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WishlistSection = append(c.inters.WishlistSection, interceptors...)
}

// Create returns a builder for creating a WishlistSection entity.
func (c *WishlistSectionClient) Create() *WishlistSectionCreate {
	mutation := newWishlistSectionMutation(c.config, OpCreate)
	return &WishlistSectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WishlistSection entities.
func (c *WishlistSectionClient) CreateBulk(builders ...*WishlistSectionCreate) *WishlistSectionCreateBulk {
	return &WishlistSectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WishlistSectionClient) MapCreateBulk(slice any, setFunc func(*WishlistSectionCreate, int)) *WishlistSectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WishlistSectionCreateBulk{err: fmt.Errorf("calling to WishlistSectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WishlistSectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WishlistSectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WishlistSection.
func (c *WishlistSectionClient) Update() *WishlistSectionUpdate {
	mutation := newWishlistSectionMutation(c.config, OpUpdate)
	return &WishlistSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WishlistSectionClient) UpdateOne(ws *WishlistSection) *WishlistSectionUpdateOne {
	mutation := newWishlistSectionMutation(c.config, OpUpdateOne, withWishlistSection(ws))
	return &WishlistSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WishlistSectionClient) UpdateOneID(id uuid.UUID) *WishlistSectionUpdateOne {
	mutation := newWishlistSectionMutation(c.config, OpUpdateOne, withWishlistSectionID(id))
	return &WishlistSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WishlistSection.
func (c *WishlistSectionClient) Delete() *WishlistSectionDelete {
	mutation := newWishlistSectionMutation(c.config, OpDelete)
	return &WishlistSectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WishlistSectionClient) DeleteOne(ws *WishlistSection) *WishlistSectionDeleteOne {
	return c.DeleteOneID(ws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WishlistSectionClient) DeleteOneID(id uuid.UUID) *WishlistSectionDeleteOne {
	builder := c.Delete().Where(wishlistsection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WishlistSectionDeleteOne{builder}
}

// Query returns a query builder for WishlistSection.
func (c *WishlistSectionClient) Query() *WishlistSectionQuery {
	return &WishlistSectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWishlistSection},
		inters: c.Interceptors(),
	}
}

// Get returns a WishlistSection entity by its id.
func (c *WishlistSectionClient) Get(ctx context.Context, id uuid.UUID) (*WishlistSection, error) {
	return c.Query().Where(wishlistsection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WishlistSectionClient) GetX(ctx context.Context, id uuid.UUID) *WishlistSection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WishlistSectionClient) Hooks() []Hook {
	return c.hooks.WishlistSection
}

// Interceptors returns the client interceptors.
func (c *WishlistSectionClient) Interceptors() []Interceptor {
	return c.inters.WishlistSection
}

func (c *WishlistSectionClient) mutate(ctx context.Context, m *WishlistSectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WishlistSectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WishlistSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WishlistSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WishlistSectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WishlistSection mutation op: %q", m.Op())
	}
}

// WishlistTemplateClient is a client for the WishlistTemplate schema.
type WishlistTemplateClient struct {
	config
}

// NewWishlistTemplateClient returns a client for the WishlistTemplate from the given config.
func NewWishlistTemplateClient(c config) *WishlistTemplateClient {
	return &WishlistTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wishlisttemplate.Hooks(f(g(h())))`.
func (c *WishlistTemplateClient) Use(hooks ...Hook) {
	c.hooks.WishlistTemplate = append(c.hooks.WishlistTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wishlisttemplate.Intercept(f(g(h())))`.
func (c *WishlistTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.WishlistTemplate = append(c.inters.WishlistTemplate, interceptors...)
}

// Create returns a builder for creating a WishlistTemplate entity.
func (c *WishlistTemplateClient) Create() *WishlistTemplateCreate {
	mutation := newWishlistTemplateMutation(c.config, OpCreate)
	return &WishlistTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WishlistTemplate entities.
func (c *WishlistTemplateClient) CreateBulk(builders ...*WishlistTemplateCreate) *WishlistTemplateCreateBulk {
	return &WishlistTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WishlistTemplateClient) MapCreateBulk(slice any, setFunc func(*WishlistTemplateCreate, int)) *WishlistTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WishlistTemplateCreateBulk{err: fmt.Errorf("calling to WishlistTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WishlistTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WishlistTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WishlistTemplate.
func (c *WishlistTemplateClient) Update() *WishlistTemplateUpdate {
	mutation := newWishlistTemplateMutation(c.config, OpUpdate)
	return &WishlistTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WishlistTemplateClient) UpdateOne(wt *WishlistTemplate) *WishlistTemplateUpdateOne {
	mutation := newWishlistTemplateMutation(c.config, OpUpdateOne, withWishlistTemplate(wt))
	return &WishlistTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WishlistTemplateClient) UpdateOneID(id uuid.UUID) *WishlistTemplateUpdateOne {
	mutation := newWishlistTemplateMutation(c.config, OpUpdateOne, withWishlistTemplateID(id))
	return &WishlistTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WishlistTemplate.
func (c *WishlistTemplateClient) Delete() *WishlistTemplateDelete {
	mutation := newWishlistTemplateMutation(c.config, OpDelete)
	return &WishlistTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WishlistTemplateClient) DeleteOne(wt *WishlistTemplate) *WishlistTemplateDeleteOne {
	return c.DeleteOneID(wt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WishlistTemplateClient) DeleteOneID(id uuid.UUID) *WishlistTemplateDeleteOne {
	builder := c.Delete().Where(wishlisttemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WishlistTemplateDeleteOne{builder}
}

// Query returns a query builder for WishlistTemplate.
func (c *WishlistTemplateClient) Query() *WishlistTemplateQuery {
	return &WishlistTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWishlistTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a WishlistTemplate entity by its id.
func (c *WishlistTemplateClient) Get(ctx context.Context, id uuid.UUID) (*WishlistTemplate, error) {
	return c.Query().Where(wishlisttemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WishlistTemplateClient) GetX(ctx context.Context, id uuid.UUID) *WishlistTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WishlistTemplateClient) Hooks() []Hook {
	return c.hooks.WishlistTemplate
}

// Interceptors returns the client interceptors.
func (c *WishlistTemplateClient) Interceptors() []Interceptor {
	return c.inters.WishlistTemplate
}

func (c *WishlistTemplateClient) mutate(ctx context.Context, m *WishlistTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WishlistTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WishlistTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WishlistTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WishlistTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WishlistTemplate mutation op: %q", m.Op())
	}
}

// WishlistTemplateSectionClient is a client for the WishlistTemplateSection schema.
type WishlistTemplateSectionClient struct {
	config
}

// NewWishlistTemplateSectionClient returns a client for the WishlistTemplateSection from the given config.
func NewWishlistTemplateSectionClient(c config) *WishlistTemplateSectionClient {
	return &WishlistTemplateSectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wishlisttemplatesection.Hooks(f(g(h())))`.
func (c *WishlistTemplateSectionClient) Use(hooks ...Hook) {
	c.hooks.WishlistTemplateSection = append(c.hooks.WishlistTemplateSection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wishlisttemplatesection.Intercept(f(g(h())))`.
func (c *WishlistTemplateSectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WishlistTemplateSection = append(c.inters.WishlistTemplateSection, interceptors...)
}

// Create returns a builder for creating a WishlistTemplateSection entity.
func (c *WishlistTemplateSectionClient) Create() *WishlistTemplateSectionCreate {
	mutation := newWishlistTemplateSectionMutation(c.config, OpCreate)
	return &WishlistTemplateSectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WishlistTemplateSection entities.
func (c *WishlistTemplateSectionClient) CreateBulk(builders ...*WishlistTemplateSectionCreate) *WishlistTemplateSectionCreateBulk {
	return &WishlistTemplateSectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WishlistTemplateSectionClient) MapCreateBulk(slice any, setFunc func(*WishlistTemplateSectionCreate, int)) *WishlistTemplateSectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WishlistTemplateSectionCreateBulk{err: fmt.Errorf("calling to WishlistTemplateSectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WishlistTemplateSectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WishlistTemplateSectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WishlistTemplateSection.
func (c *WishlistTemplateSectionClient) Update() *WishlistTemplateSectionUpdate {
	mutation := newWishlistTemplateSectionMutation(c.config, OpUpdate)
	return &WishlistTemplateSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WishlistTemplateSectionClient) UpdateOne(wts *WishlistTemplateSection) *WishlistTemplateSectionUpdateOne {
	mutation := newWishlistTemplateSectionMutation(c.config, OpUpdateOne, withWishlistTemplateSection(wts))
	return &WishlistTemplateSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WishlistTemplateSectionClient) UpdateOneID(id uuid.UUID) *WishlistTemplateSectionUpdateOne {
	mutation := newWishlistTemplateSectionMutation(c.config, OpUpdateOne, withWishlistTemplateSectionID(id))
	return &WishlistTemplateSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WishlistTemplateSection.
func (c *WishlistTemplateSectionClient) Delete() *WishlistTemplateSectionDelete {
	mutation := newWishlistTemplateSectionMutation(c.config, OpDelete)
	return &WishlistTemplateSectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WishlistTemplateSectionClient) DeleteOne(wts *WishlistTemplateSection) *WishlistTemplateSectionDeleteOne {
	return c.DeleteOneID(wts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WishlistTemplateSectionClient) DeleteOneID(id uuid.UUID) *WishlistTemplateSectionDeleteOne {
	builder := c.Delete().Where(wishlisttemplatesection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WishlistTemplateSectionDeleteOne{builder}
}

// Query returns a query builder for WishlistTemplateSection.
func (c *WishlistTemplateSectionClient) Query() *WishlistTemplateSectionQuery {
	return &WishlistTemplateSectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWishlistTemplateSection},
		inters: c.Interceptors(),
	}
}

// Get returns a WishlistTemplateSection entity by its id.
func (c *WishlistTemplateSectionClient) Get(ctx context.Context, id uuid.UUID) (*WishlistTemplateSection, error) {
	return c.Query().Where(wishlisttemplatesection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WishlistTemplateSectionClient) GetX(ctx context.Context, id uuid.UUID) *WishlistTemplateSection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WishlistTemplateSectionClient) Hooks() []Hook {
	return c.hooks.WishlistTemplateSection
}

// Interceptors returns the client interceptors.
func (c *WishlistTemplateSectionClient) Interceptors() []Interceptor {
	return c.inters.WishlistTemplateSection
}

func (c *WishlistTemplateSectionClient) mutate(ctx context.Context, m *WishlistTemplateSectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WishlistTemplateSectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WishlistTemplateSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WishlistTemplateSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WishlistTemplateSectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WishlistTemplateSection mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		LoginRequest, User, Wishlist, WishlistSection, WishlistTemplate,
		WishlistTemplateSection []ent.Hook
	}
	inters struct {
		LoginRequest, User, Wishlist, WishlistSection, WishlistTemplate,
		WishlistTemplateSection []ent.Interceptor
	}
)
